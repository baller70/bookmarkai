import { NextRequest, NextResponse } from 'next/server';
import { writeFile, readFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import { join } from 'path';
import { randomUUID } from 'crypto';
import { authenticateUser, createUnauthorizedResponse } from '@/lib/auth-utils';

// File-based storage for persistent data
const BOOKMARKS_FILE = join(process.cwd(), 'data', 'bookmarks.json');
const HISTORY_FILE = join(process.cwd(), 'data', 'bookmark_history.json');

interface Bookmark {
  id: number;
  user_id: string;
  title: string;
  url: string;
  description: string;
  category: string;
  tags?: string[];
  ai_summary?: string;
  ai_tags?: string[];
  ai_category?: string;
  notes?: string;
  created_at: string;
  updated_at: string;
  site_health?: 'excellent' | 'working' | 'fair' | 'poor' | 'broken';
  last_health_check?: string;
  healthCheckCount?: number;
  customBackground?: string;
  visits?: number;
  time_spent?: number;
  relatedBookmarks?: number[];
}

interface BookmarkVersion {
  id: string;
  bookmark_id: number;
  user_id: string;
  version_number: number;
  change_type: 'created' | 'updated' | 'deleted' | 'restored';
  changes: {
    field: string;
    old_value: any;
    new_value: any;
  }[];
  snapshot: Partial<Bookmark>; // Complete bookmark state at this version
  created_at: string;
  created_by: string;
  ip_address?: string;
  user_agent?: string;
  change_reason?: string;
  auto_generated: boolean; // True for system changes, false for user changes
}

interface HistoryResult {
  success: boolean;
  data?: any;
  message: string;
  processing_time_ms: number;
  error?: string;
}

// Ensure data directory exists
async function ensureDataDirectory() {
  const dataDir = join(process.cwd(), 'data');
  if (!existsSync(dataDir)) {
    await mkdir(dataDir, { recursive: true });
  }
}

// Load data from JSON files
async function loadBookmarks(): Promise<Bookmark[]> {
  try {
    await ensureDataDirectory();
    if (!existsSync(BOOKMARKS_FILE)) return [];
    const data = await readFile(BOOKMARKS_FILE, 'utf-8');
    return JSON.parse(data) as Bookmark[];
  } catch (error) {
    console.error('Error loading bookmarks:', error);
    return [];
  }
}

async function loadHistory(): Promise<BookmarkVersion[]> {
  try {
    await ensureDataDirectory();
    if (!existsSync(HISTORY_FILE)) return [];
    const data = await readFile(HISTORY_FILE, 'utf-8');
    return JSON.parse(data) as BookmarkVersion[];
  } catch (error) {
    console.error('Error loading history:', error);
    return [];
  }
}

// Save data to JSON files
async function saveBookmarks(bookmarks: Bookmark[]): Promise<void> {
  try {
    await ensureDataDirectory();
    await writeFile(BOOKMARKS_FILE, JSON.stringify(bookmarks, null, 2));
  } catch (error) {
    console.error('Error saving bookmarks:', error);
    throw error;
  }
}

async function saveHistory(history: BookmarkVersion[]): Promise<void> {
  try {
    await ensureDataDirectory();
    await writeFile(HISTORY_FILE, JSON.stringify(history, null, 2));
  } catch (error) {
    console.error('Error saving history:', error);
    throw error;
  }
}

// Compare two bookmark objects and return changes
function getBookmarkChanges(oldBookmark: Partial<Bookmark>, newBookmark: Partial<Bookmark>): { field: string; old_value: any; new_value: any }[] {
  const changes: { field: string; old_value: any; new_value: any }[] = [];
  
  const fieldsToTrack = [
    'title', 'url', 'description', 'category', 'tags', 'notes', 
    'ai_summary', 'ai_tags', 'ai_category', 'customBackground', 'relatedBookmarks'
  ];
  
  for (const field of fieldsToTrack) {
    const oldValue = oldBookmark[field as keyof Bookmark];
    const newValue = newBookmark[field as keyof Bookmark];
    
    // Deep comparison for arrays
    if (Array.isArray(oldValue) && Array.isArray(newValue)) {
      if (JSON.stringify(oldValue.sort()) !== JSON.stringify(newValue.sort())) {
        changes.push({ field, old_value: oldValue, new_value: newValue });
      }
    } else if (oldValue !== newValue) {
      changes.push({ field, old_value: oldValue, new_value: newValue });
    }
  }
  
  return changes;
}

// Create a new version entry
async function createVersion(
  bookmark: Bookmark, 
  changeType: BookmarkVersion['change_type'], 
  changes: BookmarkVersion['changes'],
  userId: string,
  changeReason?: string,
  autoGenerated: boolean = false
): Promise<BookmarkVersion> {
  const history = await loadHistory();
  
  // Get next version number for this bookmark
  const existingVersions = history.filter(v => v.bookmark_id === bookmark.id);
  const nextVersionNumber = existingVersions.length > 0 ? 
    Math.max(...existingVersions.map(v => v.version_number)) + 1 : 1;
  
  const newVersion: BookmarkVersion = {
    id: randomUUID(),
    bookmark_id: bookmark.id,
    user_id: bookmark.user_id,
    version_number: nextVersionNumber,
    change_type: changeType,
    changes,
    snapshot: { ...bookmark },
    created_at: new Date().toISOString(),
    created_by: userId,
    change_reason: changeReason,
    auto_generated: autoGenerated
  };
  
  history.push(newVersion);
  await saveHistory(history);
  
  return newVersion;
}

// Get version statistics for a bookmark
function getVersionStats(versions: BookmarkVersion[]) {
  const stats = {
    total_versions: versions.length,
    created_at: versions.length > 0 ? versions[0].created_at : null,
    last_updated: versions.length > 0 ? versions[versions.length - 1].created_at : null,
    change_types: versions.reduce((acc, v) => {
      acc[v.change_type] = (acc[v.change_type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>),
    most_changed_fields: versions
      .flatMap(v => v.changes.map(c => c.field))
      .reduce((acc, field) => {
        acc[field] = (acc[field] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
    contributors: [...new Set(versions.map(v => v.created_by))],
    auto_vs_manual: {
      auto: versions.filter(v => v.auto_generated).length,
      manual: versions.filter(v => !v.auto_generated).length
    }
  };
  
  return stats;
}

export async function GET(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    const authResult = await authenticateUser(request);
    if (!authResult.success) {
      return createUnauthorizedResponse(authResult.error);
    }
    const userId = authResult.userId!;

    const { searchParams } = new URL(request.url);
    const action = searchParams.get('action');
    const bookmarkId = searchParams.get('bookmark_id');
    const versionId = searchParams.get('version_id');
    const limit = parseInt(searchParams.get('limit') || '20');
    const offset = parseInt(searchParams.get('offset') || '0');
    
    if (action === 'bookmark-history' && bookmarkId) {
      console.log(`📚 Getting history for bookmark ${bookmarkId}`);
      
      const bookmarks = await loadBookmarks();
      const history = await loadHistory();
      
      // Verify bookmark access
      const bookmark = bookmarks.find(b => b.id === parseInt(bookmarkId) && b.user_id === userId);
      if (!bookmark) {
        return NextResponse.json(
          { error: 'Bookmark not found or access denied' },
          { status: 404 }
        );
      }
      
      // Get versions for this bookmark
      const bookmarkVersions = history
        .filter(v => v.bookmark_id === parseInt(bookmarkId))
        .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
        .slice(offset, offset + limit);
      
      const stats = getVersionStats(history.filter(v => v.bookmark_id === parseInt(bookmarkId)));
      
      const result: HistoryResult = {
        success: true,
        data: {
          bookmark: {
            id: bookmark.id,
            title: bookmark.title,
            url: bookmark.url
          },
          versions: bookmarkVersions,
          stats,
          pagination: {
            total: history.filter(v => v.bookmark_id === parseInt(bookmarkId)).length,
            page: Math.floor(offset / limit) + 1,
            per_page: limit,
            total_pages: Math.ceil(history.filter(v => v.bookmark_id === parseInt(bookmarkId)).length / limit)
          }
        },
        message: `Found ${bookmarkVersions.length} versions`,
        processing_time_ms: Date.now() - startTime
      };
      
      return NextResponse.json(result);
    }
    
    if (action === 'version-details' && versionId) {
      console.log(`🔍 Getting version details for ${versionId}`);
      
      const history = await loadHistory();
      const version = history.find(v => v.id === versionId);
      
      if (!version || version.user_id !== userId) {
        return NextResponse.json(
          { error: 'Version not found or access denied' },
          { status: 404 }
        );
      }
      
      // Get previous version for comparison
      const allVersions = history
        .filter(v => v.bookmark_id === version.bookmark_id)
        .sort((a, b) => a.version_number - b.version_number);
      
      const currentIndex = allVersions.findIndex(v => v.id === versionId);
      const previousVersion = currentIndex > 0 ? allVersions[currentIndex - 1] : null;
      const nextVersion = currentIndex < allVersions.length - 1 ? allVersions[currentIndex + 1] : null;
      
      const result: HistoryResult = {
        success: true,
        data: {
          version,
          previous_version: previousVersion,
          next_version: nextVersion,
          navigation: {
            has_previous: !!previousVersion,
            has_next: !!nextVersion,
            current_position: currentIndex + 1,
            total_versions: allVersions.length
          }
        },
        message: 'Version details retrieved successfully',
        processing_time_ms: Date.now() - startTime
      };
      
      return NextResponse.json(result);
    }
    
    if (action === 'user-activity') {
      console.log(`👤 Getting activity history for user: ${userId}`);
      
      const history = await loadHistory();
      const userActivity = history
        .filter(v => v.user_id === userId)
        .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime())
        .slice(offset, offset + limit);
      
      const activityStats = {
        total_changes: history.filter(v => v.user_id === userId).length,
        change_types: history
          .filter(v => v.user_id === userId)
          .reduce((acc, v) => {
            acc[v.change_type] = (acc[v.change_type] || 0) + 1;
            return acc;
          }, {} as Record<string, number>),
        most_active_period: (() => {
          const periods = history
            .filter(v => v.user_id === userId)
            .reduce((acc, v) => {
              const date = new Date(v.created_at).toISOString().split('T')[0];
              acc[date] = (acc[date] || 0) + 1;
              return acc;
            }, {} as Record<string, number>);
          
          const maxActivity = Math.max(...Object.values(periods));
          const mostActiveDate = Object.entries(periods).find(([, count]) => count === maxActivity);
          return mostActiveDate ? { date: mostActiveDate[0], changes: mostActiveDate[1] } : null;
        })()
      };
      
      const result: HistoryResult = {
        success: true,
        data: {
          activity: userActivity,
          stats: activityStats,
          pagination: {
            total: history.filter(v => v.user_id === userId).length,
            page: Math.floor(offset / limit) + 1,
            per_page: limit,
            total_pages: Math.ceil(history.filter(v => v.user_id === userId).length / limit)
          }
        },
        message: `Found ${userActivity.length} activity entries`,
        processing_time_ms: Date.now() - startTime
      };
      
      return NextResponse.json(result);
    }
    
    if (action === 'compare-versions') {
      const fromVersionId = searchParams.get('from_version_id');
      const toVersionId = searchParams.get('to_version_id');
      
      if (!fromVersionId || !toVersionId) {
        return NextResponse.json(
          { error: 'from_version_id and to_version_id are required' },
          { status: 400 }
        );
      }
      
      console.log(`🔄 Comparing versions ${fromVersionId} and ${toVersionId}`);
      
      const history = await loadHistory();
      const fromVersion = history.find(v => v.id === fromVersionId && v.user_id === userId);
      const toVersion = history.find(v => v.id === toVersionId && v.user_id === userId);
      
      if (!fromVersion || !toVersion) {
        return NextResponse.json(
          { error: 'One or both versions not found or access denied' },
          { status: 404 }
        );
      }
      
      if (fromVersion.bookmark_id !== toVersion.bookmark_id) {
        return NextResponse.json(
          { error: 'Versions must belong to the same bookmark' },
          { status: 400 }
        );
      }
      
      const changes = getBookmarkChanges(fromVersion.snapshot, toVersion.snapshot);
      
      const result: HistoryResult = {
        success: true,
        data: {
          from_version: fromVersion,
          to_version: toVersion,
          changes,
          summary: {
            fields_changed: changes.length,
            version_difference: toVersion.version_number - fromVersion.version_number,
            time_difference: new Date(toVersion.created_at).getTime() - new Date(fromVersion.created_at).getTime()
          }
        },
        message: `Comparison completed: ${changes.length} differences found`,
        processing_time_ms: Date.now() - startTime
      };
      
      return NextResponse.json(result);
    }
    
    return NextResponse.json(
      { 
        error: 'Invalid action or missing parameters',
        available_actions: ['bookmark-history', 'version-details', 'user-activity', 'compare-versions']
      },
      { status: 400 }
    );
    
  } catch (error) {
    console.error('History operation error:', error);
    
    const result: HistoryResult = {
      success: false,
      message: 'History operation failed',
      processing_time_ms: Date.now() - startTime,
      error: (error as Error).message
    };
    
    return NextResponse.json(result, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  const startTime = Date.now();
  
  try {
    const authResult = await authenticateUser(request);
    if (!authResult.success) {
      return createUnauthorizedResponse(authResult.error);
    }
    const userId = authResult.userId!;

    const body = await request.json();
    const { action, bookmark_id, version_id, change_reason } = body;
    
    if (action === 'restore-version') {
      console.log(`🔄 Restoring bookmark ${bookmark_id} to version ${version_id}`);
      
      const bookmarks = await loadBookmarks();
      const history = await loadHistory();
      
      // Find the version to restore
      const versionToRestore = history.find(v => v.id === version_id && v.user_id === userId);
      if (!versionToRestore) {
        return NextResponse.json(
          { error: 'Version not found or access denied' },
          { status: 404 }
        );
      }
      
      // Find current bookmark
      const bookmarkIndex = bookmarks.findIndex(b => b.id === bookmark_id && b.user_id === userId);
      if (bookmarkIndex === -1) {
        return NextResponse.json(
          { error: 'Bookmark not found or access denied' },
          { status: 404 }
        );
      }
      
      const currentBookmark = bookmarks[bookmarkIndex];
      const restoredSnapshot = versionToRestore.snapshot as Bookmark;
      
      // Create version entry for current state before restoration
      const changes = getBookmarkChanges(currentBookmark, restoredSnapshot);
      await createVersion(currentBookmark, 'updated', changes, userId, `Backup before restoration to version ${versionToRestore.version_number}`, true);
      
      // Restore the bookmark to the snapshot state
      const restoredBookmark: Bookmark = {
        ...restoredSnapshot,
        id: currentBookmark.id, // Keep the same ID
        user_id: currentBookmark.user_id, // Keep the same user ID
        updated_at: new Date().toISOString() // Update the timestamp
      };
      
      bookmarks[bookmarkIndex] = restoredBookmark;
      await saveBookmarks(bookmarks);
      
      // Create version entry for the restoration
      await createVersion(restoredBookmark, 'restored', changes, userId, change_reason || `Restored to version ${versionToRestore.version_number}`, false);
      
      const result: HistoryResult = {
        success: true,
        data: {
          restored_bookmark: restoredBookmark,
          restored_from_version: versionToRestore.version_number,
          changes_applied: changes.length
        },
        message: `Bookmark restored to version ${versionToRestore.version_number}`,
        processing_time_ms: Date.now() - startTime
      };
      
      return NextResponse.json(result);
    }
    
    if (action === 'create-manual-version') {
      console.log(`📝 Creating manual version for bookmark ${bookmark_id}`);
      
      const bookmarks = await loadBookmarks();
      const bookmark = bookmarks.find(b => b.id === bookmark_id && b.user_id === userId);
      
      if (!bookmark) {
        return NextResponse.json(
          { error: 'Bookmark not found or access denied' },
          { status: 404 }
        );
      }
      
      // Create a manual version entry (snapshot of current state)
      const version = await createVersion(bookmark, 'updated', [], userId, change_reason || 'Manual version created', false);
      
      const result: HistoryResult = {
        success: true,
        data: { version },
        message: 'Manual version created successfully',
        processing_time_ms: Date.now() - startTime
      };
      
      return NextResponse.json(result);
    }
    
    return NextResponse.json(
      { 
        error: 'Invalid action',
        available_actions: ['restore-version', 'create-manual-version']
      },
      { status: 400 }
    );
    
  } catch (error) {
    console.error('History operation error:', error);
    
    const result: HistoryResult = {
      success: false,
      message: 'History operation failed',
      processing_time_ms: Date.now() - startTime,
      error: (error as Error).message
    };
    
    return NextResponse.json(result, { status: 500 });
  }
}

// Note: createVersion function is defined in this file but not exported
// If other APIs need versioning, they should import from a shared utility module    