import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { writeFile, readFile, mkdir } from 'fs/promises'
import { existsSync } from 'fs'
import { join } from 'path'

// In-memory analytics store for file fallback mode (persisted to data/analytics.json in dev)
const ANALYTICS_FILE = join(process.cwd(), 'data', 'analytics.json')
const analyticsStore = new Map<string, {
  bookmark_id: string;
  visits: number;
  sessionCount: number;
  weeklyVisits: number;
  monthlyVisits: number;
  lastVisited: string;
  timeSpent: number;
}>();

async function ensureDataDirectory() {
  const dir = join(process.cwd(), 'data')
  if (!existsSync(dir)) {
    await mkdir(dir, { recursive: true })
  }
}

async function loadAnalyticsFromFile() {
  try {
    await ensureDataDirectory()
    if (!existsSync(ANALYTICS_FILE)) return
    const data = await readFile(ANALYTICS_FILE, 'utf-8')
    const parsed: Array<{ bookmark_id: string; visits: number; sessionCount: number; weeklyVisits: number; monthlyVisits: number; lastVisited: string; timeSpent: number; }> = JSON.parse(data)
    analyticsStore.clear()
    for (const a of parsed) analyticsStore.set(String(a.bookmark_id), a)
  } catch (e) {
    console.warn('Failed to load analytics file:', (e as Error).message)
  }
}

async function saveAnalyticsToFile() {
  try {
    await ensureDataDirectory()
    const arr = Array.from(analyticsStore.values())
    await writeFile(ANALYTICS_FILE, JSON.stringify(arr, null, 2))
  } catch (e) {
    console.warn('Failed to save analytics file:', (e as Error).message)
  }
}

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL?.trim()
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY?.trim()

// Disable Supabase - using Prisma/file storage now
const USE_SUPABASE = false
// Use file fallback when Supabase is disabled
const USE_FILES_FALLBACK = !USE_SUPABASE

const supabase = null;

console.log('üîß Analytics Storage Configuration:');
console.log('üìä USE_SUPABASE:', USE_SUPABASE);
console.log('üìÅ USE_FILES_FALLBACK:', USE_FILES_FALLBACK);

function getUtcMondayStartISO(d: Date) {
  const date = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()))
  const day = date.getUTCDay() // 0 Sun ... 1 Mon
  const diff = (day === 0 ? -6 : 1 - day) // shift back to Monday
  date.setUTCDate(date.getUTCDate() + diff)
  date.setUTCHours(0, 0, 0, 0)
  return date.toISOString()
}

function getUtcMondayStart(): Date {
  const d = new Date()
  const monday = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()))
  const day = monday.getUTCDay()
  const diff = (day === 0 ? -6 : 1 - day)
  monday.setUTCDate(monday.getUTCDate() + diff)
  monday.setUTCHours(0,0,0,0)
  return monday
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const { bookmarkId, action, timeSpent } = body

    if (!bookmarkId) {
      return NextResponse.json({ error: 'Bookmark ID is required' }, { status: 400 })
    }

    // If using file fallback, store analytics in memory and persist to file
    if (USE_FILES_FALLBACK) {
      await loadAnalyticsFromFile()
      console.log('üìä Analytics tracking (file fallback):', { bookmarkId, action, timeSpent });
      
      const bookmarkKey = String(bookmarkId);
      
      let analytics = analyticsStore.get(bookmarkKey);
      if (!analytics) {
        analytics = {
          bookmark_id: bookmarkKey,
          visits: 0,
          sessionCount: 0,
          weeklyVisits: 0,
          monthlyVisits: 0,
          lastVisited: new Date().toISOString(),
          timeSpent: 0
        };
      }
      
      if (action === 'visit') {
        analytics.visits += 1;
        analytics.sessionCount += 1;
        analytics.weeklyVisits += 1;
        analytics.monthlyVisits += 1;
        analytics.lastVisited = new Date().toISOString();
      } else if (action === 'timeUpdate' && timeSpent !== undefined) {
        analytics.timeSpent = timeSpent;
      }
      
      analyticsStore.set(bookmarkKey, analytics);
      await saveAnalyticsToFile()
      
      console.log('üíæ Updated analytics for bookmark', bookmarkKey, ':', analytics);
      
      return NextResponse.json({ 
        success: true, 
        analytics: {
          ...analytics,
          action: action,
          tracked_at: new Date().toISOString()
        } 
      })
    }

    // This code should not be reached if USE_FILES_FALLBACK is true
    // Log error and return success to prevent breaking the app
    console.error('‚ö†Ô∏è Analytics: Reached Supabase code path but Supabase is disabled');
    return NextResponse.json({ 
      success: true,
      analytics: {
        bookmark_id: bookmarkId,
        visits: 1,
        sessionCount: 0,
        weeklyVisits: 1,
        monthlyVisits: 1,
        lastVisited: new Date().toISOString(),
        timeSpent: 0
      },
      message: 'Analytics tracking skipped (storage not configured)'
    });

  } catch (error) {
    console.error('Analytics API error:', error)
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json({ error: 'Failed to update analytics', details: errorMessage }, { status: 500 })
  }
}

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    const bookmarkId = searchParams.get('bookmarkId')

    if (USE_FILES_FALLBACK) {
      await loadAnalyticsFromFile()
      if (bookmarkId && bookmarkId.trim() !== '') {
        const bookmarkKey = String(bookmarkId);
        const analytics = analyticsStore.get(bookmarkKey);
        if (analytics) {
          return NextResponse.json({ success: true, data: analytics })
        } else {
          return NextResponse.json({ 
            success: true, 
            data: { 
              bookmark_id: bookmarkKey,
              visits: 0, 
              sessionCount: 0, 
              weeklyVisits: 0,
              monthlyVisits: 0,
              lastVisited: null,
              timeSpent: 0
            } 
          })
        }
      } else {
        const allAnalytics = Array.from(analyticsStore.values());
        const totalVisits = allAnalytics.reduce((sum, a) => sum + a.visits, 0);
        const totalBookmarks = allAnalytics.length;
        
        return NextResponse.json({ 
          success: true, 
          data: { 
            analytics: allAnalytics, 
            globalStats: {
              totalVisits,
              totalBookmarks,
              activeBookmarks: allAnalytics.filter(a => a.visits > 0).length,
              avgUsage: totalBookmarks > 0 ? Math.round(totalVisits / totalBookmarks) : 0,
              topPerformer: allAnalytics.length > 0 ? 
                allAnalytics.reduce((top, current) => current.visits > top.visits ? current : top) : null,
              lastUpdated: new Date().toISOString()
            }
          } 
        })
      }
    }

    // This code should not be reached if USE_FILES_FALLBACK is true
    console.error('‚ö†Ô∏è Analytics GET: Reached Supabase code path but Supabase is disabled');
    return NextResponse.json({ 
      success: true, 
      data: { 
        analytics: [], 
        globalStats: {
          totalVisits: 0,
          totalBookmarks: 0,
          activeBookmarks: 0,
          avgUsage: 0,
          topPerformer: null,
          lastUpdated: new Date().toISOString()
        }
      } 
    });
  } catch (error) {
    console.error('Error fetching analytics:', error)
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred';
    return NextResponse.json({ error: 'Failed to fetch analytics', details: errorMessage }, { status: 500 })
  }
}    